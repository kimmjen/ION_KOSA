# 용어 정리

## 1. class
- 자바에서 클래스(class)란 객체를 정의하는 틀 또는 설계도와 같은 의미로 사용된다.
- 클래스는 객체의 상태를 나타내는 필드(field)와 객체의 행동을 나타내는 메소드(method)로 구성된다.
- 필드(field)란, 클래스에 포함된 변수(variable)를 의미한다.
- 메소드(method)란, 어떠한 특정 작업을 수행하기 위한 명령문의 집합을 의미

## 2. 정보은닉(캡슐화) / 상속 / 다형성 / 추상화
> 2-1. 캡슐화(Encapsulation)
- 개념: 객체의 필드(속성)과 메소드를 하나로 묶고 실제 구현 내용을 외부에 감추는 것
- 목적: 객체가 가지고 있는 데이터를 외부로부터 변질되지 않게 보호하기 위함
- '데이터 은닉'이라고도 함
- 외부 객체는 객체 내부의 구조를 얻지 못하며 객체가 노출해서 제공하는 데이터 필드와 메소드만 이용할 수 있음
- 자바는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지 결정하기 위해 접근 제어자(Acess Modifier)를 사용함.

> 2-2. 상속(Inheritance)
- 개념: 부모 클래스를 상속받은 지식 클래스는 부모 클래스의 속성과 기능을 이용할 수 있음.
- 상속의 장점
    - 클래스의 간결화: 멤버의 중복 작성 불필요
    - 클래스의 관리 용이: 클래스들의 계층적 분류
    - 소프트웨어의 생산성 향상: 클래스 재사용과 확장 용이
- 구현방법: 클래스 이름 옆에 extends 키워드 사용
- is - a 관계: '하위 객체 is a 상위 객체'로 정의 가능
- 개념적으로 상위 클래스가 더 크지만, 기능적으로 하위 객체가 더 크다.
> 2-3. 다형성(Polymorphism)
- 개념: 같은 이름의 메소그닥 클래스 혹은 객체에 따라 다르게 동작하도록 구현되는것
- 실제 동작은 다르더라도 개념적으로 동일한 작업을 메소드에 똑같은 이름을 부여하여 코드의 중복을 줄일 수 있음.
- 오버라이딩(overriding)과 오버로딩(overloading)이 다형성의 대표적인 예
> 2-4. 추상화(Abstraction)
- 개념: 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단히 만드는 기법
- 복잡성을 관리하는데 사용됨
- 객체화하는 작업에서 수 많은 속성이나 기능을 다 표현하기엔 한계가 있으므로 불필요한 것만을 남기고 불필요한 기능을 삭제

> 3. 접근제어자
- (접근 범위가 넓음) public > protected > default > private (접근범위가 좁음)


|접근제어자|같은클래스의 멤버|같은 패키지의 멤버| 자식 클래스의 멤버| 그 외의 영역|
|--|--|--|--|--|
|public|O|O|O|O|
|protected|O|O|O|X|
|default|O|O|X|X|
|private|O|X|X|X|
||||||

> 4. 생성자(Constructor)
- 자바에서는 객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 생성자(constructor)라는 메소드를 제공
- 자바에서 생성자(constructor)의 이름은 해당 클래스의 이름과 같아야 한다.
- 특징

    1. 생성자는 반환값이 없지만, 반환 타입을 void형으로 선언하지 않는다.
    2. 생성자는 초기화를 위한 데이터를 인수로 전달받을 수 있다.
    3. 객체를 초기화하는 방법이 여러 개 존재할 경우에는 하나의 클래스가 여러 개의 생성자를 가질 수 있다. 즉, 생성자도 하나의 메소드이므로, 메소드 오버로딩이 가능하다.
    - 예시
    ```java
    Car(String modelName) {}
    Car(String modelName, int modelYear) {}
    Car(String modelName, int modelYear, String color) {}
    Car(String modelName, int modelYear, String color, int maxSpeeds) {}
    ```

> 5. 멤버변수 / 멤버함수
- class구성
    |||
    |--|--|
    |클래스명| -> 클래스 헤더
    |변수   상수 (속성)| -> 멤버 필드
    |생성자|
    |메서드(동작)| -> 멤버 메서드

> 5-1. 멤버변수
- 변수와 상수를 의미, 객체가 만들어 질 때 그 객체의 특징적인 속성을 담아 두는 것, 필드의 형태가 static 이냐, instance냐에 따라서 필드의 개념이 달라진다.
> 5-2. 멤버함수
- 특정한 일을 수행하는 행위, 멤버변수들의 값을 가지고 작업을 수행할 수도 있으며, 메소드도 static 메소드와 instance 메소드라는 두 가지 종류가 있다. static메소드는 메소드를 가지는 객체를 생성하지 않아도 사용가능, instance 메소드는 객체를 생성해야만 사용 가능

## 6. overload
- 정의 : 자바의 한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메소드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메소드를 정의할 수 있다.

- 조건 : 메소드의 이름이 같고, 매개변수의 개수나 타입이 달라야 한다.

- 목적
    1. 같은 기능을 하는 메소드를 하나의 이름으로 사용할 수 있다.

    2. 메소드의 이름을 절약할 수 있다.

```java
class OverloadTest {
	public void print() {
		System.out.println("오버로딩 1");
	}
	String print(Integer a) {
		System.out.println("오버로딩 2");
		return a.toString();
	}
	void print(String a) {
		System.out.println("오버로딩 3" + a);
	}
	String print(Integer a, Integer b) {
		System.out.println("오버로딩 4");
		return a.toString() + b.toString();
	}
}
```

## 7. override
- 정의 : 부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의하는 것을 오버라이딩이라고 한다.

- 조건 : 오버라이딩은 부모 클래스의 메소드를 재정의하는 것이므로, 자식 클래스에서는 오버라이딩하고자 하는 메소드의 이름, 매개 변수, 리턴 값이 모두 같아야 한다.

- 오버라이딩 규칙

    1. 자식 클래스에서 오버라이딩하는 메소드의 접근 제어자는 부모 클래스보다 더 좁게 설정할 수 없다.

    2. 예외(Exception)는 부모 클래스의 메소드보다 많이 선언할 수 없다.

    3. static 메소드를 인스턴스의 메소드로 또는 그 반대로 바꿀 수 없다.

```java
class Person {
	void cry() {
		System.out.println("흑흑");
	}
}
class Child extends Person { // 상속
	@Override
	protected void cry() { // 재정의
		System.out.println("잉잉");
	}
}
class Senior extends Person { // 상속
	@Override
	public void cry() { // 재정의
		System.out.println("훌쩍훌쩍");
	}
}
```

## 8. object / instance
> 8-1. object
- 개념
    - 소프트웨어 세계에 구현할 대상
    - 클래스에 선언된 모양 그대로 생성된 실체
- 특징
    - '클래스의 인스턴스(instance)'라고도 부른다.
    - 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.
    - oop의 관점에서 클래스의 타입으로 선언되었을 때 '객체'라고 부른다.
> 8-2. instance
- 개념
    - 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
        - 즉, 객체를 소프트웨어에 실체화 하면 그것을 '인스턴스'라고 부른다.
        - 실체화된 인스턴스는 메모리에 할당된다.
- 특징
    - 인스턴스는 객체에 포함된다고 볼 수 있다.
    - oop의 관점에서 객체가 메모리에 할당되어 실제 사용될 때 '인스턴스'라고 부른다.
    - 추상적인 개념(또는 명세)과 구체적인 객체 사이의 관계에 초점을 맞출 경우에 사용한다.
        - '~의 인스턴스'의 형태로 사용된다.
        - 객체는 클래스의 인스턴스다.
        - 객체 간의 링크는 클래스 간의 연관 관계의 인스턴스다.
        - 실행 프로세스는 프로그램의 인스턴스다.
    - 즉, 인스턴스라는 용어는 반드시 클래스와 객체 사이의 관계로 한정지어서 사용할 필요는 없다.
    - 인스턴스는 어떤 원본(추상적인 개념)으로부터 '생성된 복제본'을 의미한다.
> 8-3. object(객체) vs instance(인스턴스)
- 클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
- 객체는 현실 세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다.
- 객체는 '실체', 인스턴스는 '관계'에 초점을 맞춘다.
    - 객체를 '클래스의 인스턴스'라고도 부른다.

```java
public class Animal {
	...
}
public class Main {
	public static void main(String[] args) {
		Animal cat, dog; // 객체

		// 인스턴스화
		cat = new Animal(); // cat은 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
		dog = new Animal(); // dog는 Animal 클래스의 '인스턴스'(객체를 메모리에 할당)
	}
}
```

## 9. interface
- 개념
    - 클래스를 이용한 다중 상속은 메소드 출처의 모호성 등 여러 가지 문제가 발생할 수 있어 자바에서는 클래스를 통한 다중 상속은 지원하지 않는다. 하지만, 다중 상속의 이점을 사용하기 위해 인터페이스를 통해 다중 상속을 지원한다.
    - 인터페이스(interface)란 다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스를 의미한다.
    - 인터페이스(interface)는 오로지 추상 메소드와 상수만을 포함할 수 있다.
- 인터페이스의 작성
    - 클래스와는 달리 인터페이스의 모든 필드는 public static final이어야 하며, 모든 메소드는 public abstract이어야 한다.

    ```java
    public interface interfaceTest {
    	public static final 타입 상수이름 = 값;
    	...
    	public abstract 메소드이름(매개변수목록);
    	...
    }
    ```

- 인터페이스의 장점
    1. 대규모 프로젝트 개발 시 일관되고 정형화된 개발을 위한 표준화가 가능하다.
    2. 클래스의 작성과 인터페이스의 구현을 동시에 진행할 수 있으므로, 개발 시간을 단축할 수 있다.
    3. 클래스와 클래스 간의 관계를 인터페이스로 연결하면, 클래스마다 독립적인 프로그래밍이 가능하다.

## 10. abstract

> 10-1. 추상 메소드(abstract method)

- 개념 : 추상 메소드(abstract method)란 자식 클래스에서 반드시 오버라이딩해야만 사용할 수 있는 메소드를 의미한다.
- 추상 메소드는 선언부만 있고 구현부가 없다는 의미로 선언부 끝에 바로 세미콜론(;)을 추가한다.

```java
abstract 반환타입 메소드이름();
```

> 10-2. 추상 클래스(abstract class)

- 개념 : 하나 이상의 추상 메소드를 포함하는 클래스를 가리켜 추상 클래스(abstract class)라고 한다.
- 추상 클래스는 객체 지향 프로그래밍에서 중요한 특징인 다형성을 가지는 메소드의 집합을 정의할 수 있도록 해준다.

```java
abstract class 클래스이름 {
    ...
    abstract 반환타입 메소드이름();
    ...
}
```

## 11. this / static

> 11-1. this

- 각각의 저장 메모리의 위치에 따라 필드 값과 메소드가 상이 → 따라서 클래스 내의 필드, 클래스 내의 메소드를 표현하는 경우 this 사용
- this를 사용하는 경우
    1. 메소드의 지역변수명(매개변수명)과 필드명이 동일한 경우 → this.필드명
    2. 생성자 선언 시 다른 생성자를 호출하려 초기화 작업을 하는 경우
    3. 메소드에서 호출한 인스턴스 표기 시 사용
- 코드 예시

    ```java
    public class Test {
    	private int value1;
    	pirvate int value2;

    	public Test(int value1, int value2) {
    		this.value1 = value1;
    		this.value2 = value2;
    	}
    }
    ```

> 11-2. static

- static 필드 (정적 필드)
    - 생성되는 인스턴스의 개수와는 무관하게 클래스가 메모리에 로딩된 후 딱 한 번 생성
    - 모든 인스턴스가 공유하는 필드 → 공유 필드
    - 초기화 작업은 필요하지 않기 때문에 생성자와도 무관

    ```java
    접근지정자 static 자료형 필드명;
    ```

- static 메소드 (정적 메소드)
    - this 매개변수가 존재하지 않는 메소드
    - 그래서 인스턴스 필드 접근 불가능, 인스턴스 메소드 호출 불가
    - 오로지 정적 필드만 접근 가능
    - 오로지 클래스를 통하여 호출 가능

    ```java
    접근지정자 static 반환명 메소드명(static 필드명, ...) {
    	static 필드 값을 제어하는 명령;
    }
    ```